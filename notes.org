#+PROPERTY: header-args:scheme :tangle "gwl-gladiator.scm"
#+PROPERTY: header-args:nextflow :tangle "gladiator.nf" 
#+PROPERTY: header-args:dot :output-dir img :file-ext svg
#+LINK: gladiator file:../glaDIAtor/%s
* Analysis
** Headers
#+begin_src emacs-lisp :tangle no
(setq org-babel-tangle-lang-exts
      (cl-remove-duplicates 
      (append
       '(("scheme" . "scm"))
       org-babel-tangle-lang-exts
       )
      :test 'equal))
#+end_src

#+RESULTS:
: ((scheme . scm) (python . py) (D . d) (C++ . cpp) (emacs-lisp . el) (elisp . el))


#+NAME: gwl-header-block
#+begin_src scheme :noweb yes
(define-module (workflow)
  #:use-module (gwl workflows)
  #:use-module (gwl processes)
  #:use-module (gwl utils)
  #:use-module (gwl sugar))

<<gwl-vars>>
#+end_src

#+NAME: nf-header-block
#+begin_src nextflow :noweb yes 
<<nf-vars>>
#+end_src
** building database
:PROPERTIES:
:ORDERED:  t
:END:
*Overview*
[[file:glaDIAtor/workflow.py::def build_database(\\][build_database definition]]
#+NAME: dot-build-database
#+begin_src dot 
digraph {
	cat[shape=box,label="Cat with Bio.SeqIo"]
	DecoyDatabase[shape=box, ]
	DB_fasta[style=bold,label="DB.fasta"]
	DB_with_decoy[style=bold,label="DB_with_decoys.fasta"]
	all_fasta_files -> cat [label="cannot be parallized"]
	cat -> DB_fasta -> DecoyDatabase -> DB_with_decoy
}
#+end_src

#+RESULTS: dot-build-database
[[file:img/dot-build-database.svg]]


*** Combining Fasta Files
#+NAME: py-joinfastafiles
#+begin_src python :tangle no
from Bio import SeqIO
def join_fasta_files(input_files, output_file):
    IDs = set()
    seqRecords = []
    for filename in input_files:
        records = SeqIO.index(filename, "fasta")
        for ID in records:
            if ID not in IDs:
                seqRecords.append(records[ID])
                IDs.add(ID)
            else:
                print("Found duplicated sequence ID " + str(ID) + ", skipping this sequence from file " + filename)

    SeqIO.write(seqRecords, output_file, "fasta")
#+end_src

#+NAME: nf-joinfastafiles
#+begin_src nextflow :noweb yes
process JoinFastaFiles {
    input:
    file fasta_files from fasta_files_ch.collect()
    output:
    file 'joined_database.fasta' into joined_fasta_database_ch

    """
    #!/usr/bin/env python3
    <<py-joinfastafiles>>
    join_fasta_files(fasta_files, 'joined_database.fasta')
    """
}
#+end_src

#+begin_src nextflow :noweb-ref nf-vars :tangle no
params.fastafiles='fasta/*.fasta'
Channel.fromPath(params.fastafiles).set({fasta_files_ch})
#+end_src

#+NAME: gwl-joinfastafiles-deps
#+begin_src scheme :noweb-ref deps :tangle no
("join-fasta-files"
 "python"
 "biopython")
#+end_src

#+NAME: gwl-joinfastafiles
#+begin_src scheme :noweb yes
(define (join-fasta-files fasta-files)
  (make-process
   (name "join-fasta-files")
   (synopsis "Join fasta files into one file")
   (packages
    (cdr '
      <<gwl-joinfastafiles-deps>>))
   (inputs (files fasta-files))
   (outputs "joined-fasta.fasta")
   # python
{
<<py-joinfastafiles>>
join_fasta_files({{inputs}}.split(" "),{{outputs}})
}))
#+end_src

#+begin_src scheme :noweb-ref gwl-vars :tangle no
(define fasta-files
  '("Q7M135.fasta" "trypsin.fasta"))
#+end_src

*** Adding Decoys
#+NAME: nf-buildfastadatabase
#+begin_src nextflow
fasta_db_with_decoys = Channel.value()
process BuildFastaDatabase {
    input:
    file joined_fasta_db from joined_fasta_database_ch
    output:
    file "DB_with_decoys.fasta" into joined_fasta_with_decoys_ch
    """
    DecoyDatabase -in $joined_fasta_db -out DB_with_decoys.fasta
    """
}
#+end_src
=DecoyDatabase= package is from =OpenMs/utils=
https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/UTILS_DecoyDatabase.html
https://github.com/OpenMS/OpenMS.git
License: BSD-3 clause
(Not in guix, but uses cmake as build-program,
should be relatively easy to define)
** Creating Pseudospectra
[[file:glaDIAtor/workflow.py::def runDiaumpire]]
#+NAME: dot-create-pseudospectra
#+begin_src dot :file-ext svg
digraph {
    DIA[label="DIA_1.mzXML"]
    diaumpire[shape="box",label="java -jar DiaUmpire.jar"]
    pseudo_spectra[label="libfree/DIA_1.mgs"]
    diaumpire_cfg[label="diaumpirecfg.txt (singleton)"]
    pseudo_spectra_mzxml[label="libfree-pseudospectra/DIA_1.mzXML"]
		   
    DIA -> diaumpire
    diaumpire_cfg -> diaumpire
    diaumpire -> pseudo_spectra -> { msconvert[shape="box"] } -> pseudo_spectra_mzxml
}
#+end_src

#+RESULTS: dot-create-pseudospectra
[[file:img/dot-create-pseudospectra.svg]]
https://github.com/Nesvilab/DIA-Umpire/tree/master

DIAumpire is =Apache 2= licensed.
#+begin_src nextflow
process GeneratePseudoSpectra  {
    input:
    file diafile from dia_mzxml_files_for_pseudospectra_ch
    path diaumpireconfig from params.diaumpireconfig
        
    output:
    file "*.mgf" into pseudospectra_mgf_ch

    '''
    java -jar DIA_Umpire_SE.jar $diafile $diaumpireconfig
    '''
}

process MgsToMzxml {
    input:
    file mgf from pseudospectra_mgf_ch
    output:
    file "*.mzXML" into pseudospectra_ch
    
    '''
    msconvert $mgf --mzXML 
    '''
}
#+end_src 
#+begin_src scheme :noweb-ref deps :tangle no 
("generate-pseudo-spectra"
 "dia-umpire" 
 "pwiz") ;; the free one 
#+end_src


though this  might also be done with openms's =FileConverter= ? which is more conventionally build 
https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/release/latest/html/TOPP_FileConverter.html
mstools
#+begin_src nextflow :noweb-ref nf-vars :tangle no
params.diaumpireconfig='diaumpireconfig.txt'
params.diafiles = "dia/*.mzXML"
params.ddafiles = "dda/*.mzML"

Channel.fromPath(params.ddafiles).into{dda_files_ch ; dda_files_empty_check}
dda_assisted_p = dda_files_empty_check.ifEmpty('Empty').first() != 'Empty'

(dia_mzxml_files_ch, dia_mzxml_files_for_pseudospectra_ch) =
  (dda_assisted_p ?
    [ Channel.fromPath(params.diafiles), Channel.empty() ] :
    Channel.fromPath(params.diafiles).into(2))

#+end_src 
As dia will be listened to by two in the case of not dda-assisted,
we'll have to use the [[https://www.nextflow.io/docs/latest/operator.html#operator-into][=into=]] operator to input into two channels if we dont have =dda=  data



** Creating interactome

* Putting it together
** gwl
#+begin_src scheme
(make-workflow
 (name "my-workflow")
 (processes
  (auto-connect
   (list (join-fasta-files fasta-files)))))
#+end_src

* File local variables
For this file

# Local Variables:
# compile-command: "cd /data/epouta1/B22003_Elixir_DIA_Nextflow/playground/ && module use /appl/user/modulefiles/ && module load nextflow && salloc nextflow run gladiator.nf"
# End:

For the scheme file

#+begin_src scheme
;; Local Variables;
;; compile-command: "guix shell guix guile gwl --with-git-url=gwl=git://git.savannah.gnu.org/gwl.git --with-commit=gwl=e233be5cf0e2f9cb37e3daa299f5031bea56ba71 -- guix workflow run -v10 gwl-gladiator.scm
;; End:
#+end_src
For the nextflow file
#+begin_src nextflow
// Local Variables:
// compile-command: "module use /appl/user/modulefiles/ && module load nextflow && salloc nextflow run gladiator.nf"
// End:
#+end_src

* COMMENT for editing
#+begin_src emacs-lisp :tangle no :results none
(defun set-local-abbrevs (abbrevs)
  "Add ABBREVS to `local-abbrev-table' and make it buffer local.
ABBREVS should be a list of abbrevs as passed to `define-abbrev-table'.
The `local-abbrev-table' will be replaced by a copy with the new abbrevs added,
so that it is not the same as the abbrev table used in other buffers with the
same `major-mode'."
  (let* ((bufname (buffer-name))
         (prefix (substring (md5 bufname) 0 (length bufname)))
         (tblsym (intern (concat prefix "-abbrev-table"))))
    (set tblsym (copy-abbrev-table local-abbrev-table))
    (dolist (abbrev abbrevs)
      (define-abbrev (eval tblsym)
        (cl-first abbrev)
        (cl-second abbrev)
        (cl-third abbrev)))
    (setq-local local-abbrev-table (eval tblsym))))
(set-local-abbrevs '(
		     ("nfv"
		      "#+begin_src nextflow :noweb-ref nf-vars :tangle no\n\n#+end_src"
		      previous-line)
		     ("gwv"
		      "#+begin_src scheme :noweb-ref gwl-vars :tangle no\n\n#+end_src"
		      previous-line)
		     ("wfd"
		      "#+begin_src scheme :noweb-ref deps :tangle no \n\n#+end_src"
		      previous-line)))

#+end_src


#+begin_src emacs-lisp
(defun gladiator-compile-test ()
  (interactive)
  (let ((default-directory (concat (file-remote-p default-directory)
				   "/data/epouta1/B22003_Elixir_DIA_Nextflow/playground/"))
	;; dont ask about saving things
	(compilation-save-buffers-predicate 'ignore))
    (compile "module use /appl/user/modulefiles/ && module load nextflow && salloc nextflow run gladiator.nf")))

(defun gladiator-tangle-and-compile ()
  (interactive)
  (when (buffer-modified-p)
    (call-interactively 'org-babel-tangle))
  (gladiator-compile-test))

(use-local-map (copy-keymap org-mode-map))
(local-set-key (kbd "C-c m") 'gladiator-tangle-and-compile)
#+end_src

#+RESULTS:
: gladiator-tangle-and-compile





